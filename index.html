<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FOLDER VISION</title>
<meta name="description" content="„Éï„Ç©„É´„ÉÄÊßãÈÄ†„ÇíD3.js„Åß„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Å´ÂèØË¶ñÂåñ„Åô„Çã„ÉÑ„Éº„É´">
<meta property="og:title" content="FOLDER VISION">
<meta property="og:description" content="File System Access API„ÅßPC„ÅÆ„Éï„Ç©„É´„ÉÄ„ÇíÈñã„Åç„ÄÅ‰∏≠Ë∫´„ÅÆ„Éï„Ç°„Ç§„É´ÊßãÈÄ†„ÇíD3.js„Åß„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Å´ÂèØË¶ñÂåñ„Åô„Çã„ÉÑ„Éº„É´">
<meta property="og:image" content="https://paul13131313.github.io/folder-vision/ogp.png">
<meta property="og:url" content="https://paul13131313.github.io/folder-vision/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìÇ</text></svg>">
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #0a0a0a;
  --text: #e0e0e0;
  --text-dim: #888;
  --border: rgba(255,255,255,0.15);
  --accent: #00d4ff;
  --code: #00d4ff;
  --web: #ff00aa;
  --data: #ffaa00;
  --image: #00ff88;
  --document: #ffffff;
  --media: #aa66ff;
  --config: #888888;
  --other: #555555;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'JetBrains Mono', monospace;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
}

/* ===== LANDING ===== */
#landing {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  gap: 24px;
}

#landing h1 {
  font-size: 48px;
  font-weight: 700;
  letter-spacing: 8px;
  color: var(--text);
}

#landing p {
  color: var(--text-dim);
  font-size: 14px;
  max-width: 480px;
  text-align: center;
  line-height: 1.6;
}

.open-btn {
  padding: 16px 48px;
  font-size: 16px;
  font-family: inherit;
  font-weight: 600;
  letter-spacing: 4px;
  color: var(--accent);
  background: rgba(0, 212, 255, 0.08);
  border: 1px solid rgba(0, 212, 255, 0.3);
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
}
.open-btn:hover {
  background: rgba(0, 212, 255, 0.15);
  border-color: rgba(0, 212, 255, 0.6);
  box-shadow: 0 0 20px rgba(0, 212, 255, 0.15);
}

.browser-warning {
  color: #ff6b6b;
  font-size: 12px;
  display: none;
}

/* ===== MAIN APP ===== */
#app {
  display: none;
  height: 100vh;
  width: 100vw;
  flex-direction: column;
}

/* Header */
#header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  min-height: 56px;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 16px;
}

.header-left h1 {
  font-size: 16px;
  font-weight: 700;
  letter-spacing: 4px;
  white-space: nowrap;
}

.folder-name {
  color: var(--text-dim);
  font-size: 13px;
}

.stats-summary {
  color: var(--text-dim);
  font-size: 12px;
  display: flex;
  gap: 12px;
}
.stats-summary span {
  white-space: nowrap;
}

.header-right {
  display: flex;
  align-items: center;
  gap: 8px;
}

.mode-btn {
  padding: 6px 14px;
  font-size: 11px;
  font-family: inherit;
  font-weight: 600;
  letter-spacing: 2px;
  color: var(--text-dim);
  background: transparent;
  border: 1px solid var(--border);
  border-radius: 3px;
  cursor: pointer;
  transition: all 0.3s;
}
.mode-btn:hover {
  color: var(--text);
  border-color: rgba(255,255,255,0.3);
}
.mode-btn.active {
  color: var(--accent);
  border-color: rgba(0,212,255,0.4);
  background: rgba(0,212,255,0.08);
}

.search-box {
  padding: 6px 12px;
  font-size: 12px;
  font-family: inherit;
  color: var(--text);
  background: rgba(255,255,255,0.05);
  border: 1px solid var(--border);
  border-radius: 3px;
  outline: none;
  width: 180px;
  transition: border-color 0.3s;
}
.search-box:focus {
  border-color: rgba(0,212,255,0.4);
}
.search-box::placeholder {
  color: var(--text-dim);
}

.new-folder-btn {
  padding: 6px 14px;
  font-size: 11px;
  font-family: inherit;
  font-weight: 600;
  letter-spacing: 1px;
  color: var(--text-dim);
  background: transparent;
  border: 1px solid var(--border);
  border-radius: 3px;
  cursor: pointer;
  transition: all 0.3s;
}
.new-folder-btn:hover {
  color: var(--text);
  border-color: rgba(255,255,255,0.3);
}

/* Breadcrumb */
#breadcrumb {
  padding: 6px 20px;
  font-size: 12px;
  color: var(--text-dim);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  gap: 4px;
  min-height: 32px;
}
#breadcrumb span {
  cursor: pointer;
  transition: color 0.2s;
}
#breadcrumb span:hover {
  color: var(--accent);
}
#breadcrumb .sep {
  cursor: default;
  color: rgba(255,255,255,0.2);
}
#breadcrumb .current {
  color: var(--text);
  cursor: default;
}

/* Main content area */
#content {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* Stats panel */
#stats-panel {
  width: 260px;
  border-right: 1px solid var(--border);
  padding: 16px;
  overflow-y: auto;
  flex-shrink: 0;
  font-size: 12px;
}

.stat-section {
  margin-bottom: 20px;
}
.stat-section h3 {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 2px;
  color: var(--text-dim);
  margin-bottom: 10px;
  text-transform: uppercase;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  border-bottom: 1px solid rgba(255,255,255,0.04);
}
.stat-row .label { color: var(--text-dim); }
.stat-row .value { color: var(--text); font-weight: 600; }

.type-bar {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 3px 0;
}
.type-bar .color-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}
.type-bar .type-name {
  flex: 1;
  color: var(--text-dim);
  font-size: 11px;
}
.type-bar .type-count {
  color: var(--text);
  font-size: 11px;
  font-weight: 600;
}
.type-bar-fill {
  height: 3px;
  border-radius: 2px;
  margin-top: 2px;
  margin-bottom: 4px;
  opacity: 0.6;
}

.top-file {
  padding: 4px 0;
  border-bottom: 1px solid rgba(255,255,255,0.04);
}
.top-file .file-name {
  color: var(--text);
  font-size: 11px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.top-file .file-size {
  color: var(--text-dim);
  font-size: 10px;
}

/* Visualization area */
#viz {
  flex: 1;
  position: relative;
  overflow: hidden;
}

#viz svg {
  width: 100%;
  height: 100%;
}

/* Tooltip */
#tooltip {
  position: fixed;
  display: none;
  background: rgba(20, 20, 20, 0.95);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 10px 14px;
  font-size: 12px;
  pointer-events: none;
  z-index: 100;
  max-width: 350px;
  backdrop-filter: blur(8px);
}
#tooltip .tt-name {
  font-weight: 600;
  margin-bottom: 4px;
  word-break: break-all;
}
#tooltip .tt-row {
  color: var(--text-dim);
  font-size: 11px;
  padding: 1px 0;
}
#tooltip .tt-row strong {
  color: var(--text);
  font-weight: 600;
}

/* Scanning overlay */
#scanning {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(10,10,10,0.9);
  z-index: 200;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
}
#scanning.active {
  display: flex;
}
#scanning .scan-text {
  font-size: 14px;
  letter-spacing: 2px;
  color: var(--text);
}
#scanning .scan-count {
  font-size: 24px;
  font-weight: 700;
  color: var(--accent);
}
#scanning .scan-sub {
  font-size: 12px;
  color: var(--text-dim);
}

.spinner {
  width: 40px;
  height: 40px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<!-- Landing screen -->
<div id="landing">
  <h1>FOLDER VISION</h1>
  <p>File System Access API„ÅßPC„ÅÆ„Éï„Ç©„É´„ÉÄ„ÇíÈñã„Åç„ÄÅD3.js„Åß„Éï„Ç°„Ç§„É´ÊßãÈÄ†„Çí„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Å´ÂèØË¶ñÂåñ„Åó„Åæ„Åô„ÄÇ</p>
  <button class="open-btn" id="openBtn">OPEN FOLDER</button>
  <p class="browser-warning" id="browserWarning">‚ö† „Åì„ÅÆ„ÉÑ„Éº„É´„ÅØChrome 86‰ª•Èôç„Åß„ÅÆ„ÅøÂãï‰Ωú„Åó„Åæ„Åô„ÄÇ</p>
</div>

<!-- Scanning overlay -->
<div id="scanning">
  <div class="spinner"></div>
  <div class="scan-text">SCANNING</div>
  <div class="scan-count" id="scanCount">0</div>
  <div class="scan-sub">files found</div>
</div>

<!-- Main app -->
<div id="app">
  <div id="header">
    <div class="header-left">
      <h1>FOLDER VISION</h1>
      <span class="folder-name" id="folderName"></span>
      <div class="stats-summary" id="statsSummary"></div>
    </div>
    <div class="header-right">
      <input type="text" class="search-box" id="searchBox" placeholder="Search files...">
      <button class="mode-btn active" data-mode="treemap">TREEMAP</button>
      <button class="mode-btn" data-mode="sunburst">SUNBURST</button>
      <button class="mode-btn" data-mode="bubbles">BUBBLES</button>
      <button class="new-folder-btn" id="newFolderBtn">OPEN NEW</button>
    </div>
  </div>
  <div id="breadcrumb"></div>
  <div id="content">
    <div id="stats-panel"></div>
    <div id="viz"></div>
  </div>
</div>

<!-- Tooltip -->
<div id="tooltip">
  <div class="tt-name" id="ttName"></div>
  <div class="tt-row" id="ttDetails"></div>
</div>

<script>
// ===== FILE TYPE CLASSIFICATION =====
const FILE_TYPES = {
  Code:     { color: '#00d4ff', exts: ['js','ts','jsx','tsx','py','rb','go','rs','c','cpp','h','java','php','swift','kt','sh','bash','zsh','pl','lua','dart','scala','r','m','mm','zig','nim','ex','exs','elm','hs','clj','erl'] },
  Web:      { color: '#ff00aa', exts: ['html','htm','css','scss','sass','less','vue','svelte','astro','ejs','pug','hbs','handlebars'] },
  Data:     { color: '#ffaa00', exts: ['json','xml','yaml','yml','csv','sql','env','toml','ini','graphql','gql','proto'] },
  Image:    { color: '#00ff88', exts: ['png','jpg','jpeg','gif','svg','webp','ico','bmp','tiff','tif','avif'] },
  Document: { color: '#ffffff', exts: ['md','txt','pdf','doc','docx','rtf','tex','rst','adoc','org'] },
  Media:    { color: '#aa66ff', exts: ['mp3','mp4','wav','mov','avi','webm','ogg','flac','aac','mkv','m4a','m4v'] },
  Config:   { color: '#888888', exts: ['gitignore','eslintrc','prettierrc','editorconfig','dockerignore','babelrc','browserslistrc','npmrc','nvmrc'], names: ['package.json','tsconfig.json','webpack.config.js','vite.config.js','vite.config.ts','rollup.config.js','jest.config.js','Dockerfile','docker-compose.yml','Makefile','CMakeLists.txt','.env.local','.env.development','.env.production','tailwind.config.js','tailwind.config.ts','postcss.config.js','postcss.config.mjs','next.config.js','next.config.ts','nuxt.config.ts'] },
};

function getFileType(name) {
  const lower = name.toLowerCase();
  // Check by full name first (for config files)
  for (const [type, info] of Object.entries(FILE_TYPES)) {
    if (info.names && info.names.includes(lower)) return type;
  }
  // Check by extension
  const ext = lower.split('.').pop();
  // Also check dot-prefixed filenames like .gitignore
  const dotName = lower.startsWith('.') ? lower.slice(1) : null;
  for (const [type, info] of Object.entries(FILE_TYPES)) {
    if (info.exts.includes(ext)) return type;
    if (dotName && info.exts.includes(dotName)) return type;
  }
  return 'Other';
}

function getTypeColor(type) {
  return FILE_TYPES[type]?.color || '#555555';
}

// ===== UTILITY =====
function formatSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
}

function formatDate(ts) {
  const d = new Date(ts);
  return d.toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' });
}

const SKIP_DIRS = new Set(['node_modules', '.git', '.DS_Store', '__pycache__', '.next', '.nuxt', '.cache', '.parcel-cache', 'dist', 'build', '.svelte-kit', '.turbo', 'coverage', '.nyc_output', 'vendor', 'venv', '.venv', 'env', '__MACOSX']);

// ===== SCAN =====
let fileCount = 0;

async function scanDirectory(dirHandle, path = '') {
  const children = [];
  for await (const [name, handle] of dirHandle.entries()) {
    if (handle.kind === 'file') {
      if (name === '.DS_Store') continue;
      try {
        const file = await handle.getFile();
        children.push({
          name,
          path: path + '/' + name,
          size: file.size,
          type: getFileType(name),
          lastModified: file.lastModified,
        });
        fileCount++;
        if (fileCount % 50 === 0) {
          document.getElementById('scanCount').textContent = fileCount.toLocaleString();
          await new Promise(r => setTimeout(r, 0)); // yield to UI
        }
      } catch (e) {
        // Skip files that can't be read
      }
    } else if (handle.kind === 'directory') {
      if (SKIP_DIRS.has(name)) continue;
      const subChildren = await scanDirectory(handle, path + '/' + name);
      if (subChildren.length > 0) {
        children.push({
          name,
          path: path + '/' + name,
          children: subChildren,
        });
      }
    }
  }
  return children;
}

// ===== STATE =====
let rootData = null;
let currentMode = 'treemap';
let currentZoomNode = null;
let searchTerm = '';

// ===== STATS =====
function computeStats(node) {
  let totalFiles = 0, totalFolders = 0, totalSize = 0;
  const typeCounts = {};
  const allFiles = [];

  function walk(n) {
    if (n.children) {
      totalFolders++;
      n.children.forEach(walk);
    } else {
      totalFiles++;
      totalSize += n.size || 0;
      const t = n.type || 'Other';
      typeCounts[t] = (typeCounts[t] || 0) + 1;
      allFiles.push(n);
    }
  }
  walk(node);

  allFiles.sort((a, b) => (b.size || 0) - (a.size || 0));
  const topFiles = allFiles.slice(0, 5);

  return { totalFiles, totalFolders, totalSize, typeCounts, topFiles };
}

function renderStats(stats) {
  const panel = document.getElementById('stats-panel');
  const summaryEl = document.getElementById('statsSummary');

  summaryEl.innerHTML = `
    <span>${stats.totalFiles.toLocaleString()} files</span>
    <span>${stats.totalFolders.toLocaleString()} folders</span>
    <span>${formatSize(stats.totalSize)}</span>
  `;

  const maxTypeCount = Math.max(...Object.values(stats.typeCounts), 1);

  let html = `
    <div class="stat-section">
      <h3>OVERVIEW</h3>
      <div class="stat-row"><span class="label">Files</span><span class="value">${stats.totalFiles.toLocaleString()}</span></div>
      <div class="stat-row"><span class="label">Folders</span><span class="value">${stats.totalFolders.toLocaleString()}</span></div>
      <div class="stat-row"><span class="label">Total Size</span><span class="value">${formatSize(stats.totalSize)}</span></div>
    </div>
    <div class="stat-section">
      <h3>FILE TYPES</h3>
  `;

  const sortedTypes = Object.entries(stats.typeCounts).sort((a, b) => b[1] - a[1]);
  for (const [type, count] of sortedTypes) {
    const color = getTypeColor(type);
    const pct = (count / maxTypeCount) * 100;
    html += `
      <div class="type-bar">
        <div class="color-dot" style="background:${color}"></div>
        <span class="type-name">${type}</span>
        <span class="type-count">${count}</span>
      </div>
      <div class="type-bar-fill" style="width:${pct}%;background:${color}"></div>
    `;
  }

  html += `</div><div class="stat-section"><h3>LARGEST FILES</h3>`;
  for (const f of stats.topFiles) {
    html += `
      <div class="top-file">
        <div class="file-name" title="${f.path}">${f.name}</div>
        <div class="file-size">${formatSize(f.size)}</div>
      </div>
    `;
  }
  html += `</div>`;

  panel.innerHTML = html;
}

// ===== BREADCRUMB =====
function renderBreadcrumb(node) {
  const bc = document.getElementById('breadcrumb');
  const ancestors = [];
  let n = node;
  while (n) {
    ancestors.unshift(n);
    n = n.parent;
  }

  bc.innerHTML = '';
  ancestors.forEach((a, i) => {
    const span = document.createElement('span');
    span.textContent = a.data.name || 'root';
    if (i < ancestors.length - 1) {
      span.addEventListener('click', () => zoomTo(a));
    } else {
      span.classList.add('current');
    }
    bc.appendChild(span);
    if (i < ancestors.length - 1) {
      const sep = document.createElement('span');
      sep.classList.add('sep');
      sep.textContent = ' / ';
      bc.appendChild(sep);
    }
  });
}

// ===== TOOLTIP =====
const tooltip = document.getElementById('tooltip');
function showTooltip(e, d) {
  const data = d.data;
  document.getElementById('ttName').textContent = data.name;
  let details = '';
  if (data.children || d.children) {
    const stats = computeStats(data.children ? data : { children: d.children?.map(c => c.data) || [] });
    details = `<div class="tt-row">Folder ‚Äî <strong>${(data.children ? computeStats(data).totalFiles : 0)} files</strong></div>`;
    if (data.children) {
      const s = computeStats(data);
      details = `<div class="tt-row">Folder ‚Äî <strong>${s.totalFiles} files</strong>, <strong>${s.totalFolders} folders</strong></div>`;
      details += `<div class="tt-row">Size: <strong>${formatSize(s.totalSize)}</strong></div>`;
    }
  } else {
    details = `
      <div class="tt-row">Type: <strong>${data.type || 'Other'}</strong></div>
      <div class="tt-row">Size: <strong>${formatSize(data.size || 0)}</strong></div>
      <div class="tt-row">Modified: <strong>${formatDate(data.lastModified)}</strong></div>
      <div class="tt-row">Path: ${data.path}</div>
    `;
  }
  document.getElementById('ttDetails').innerHTML = details;

  tooltip.style.display = 'block';
  const tx = Math.min(e.clientX + 12, window.innerWidth - 360);
  const ty = Math.min(e.clientY + 12, window.innerHeight - 120);
  tooltip.style.left = tx + 'px';
  tooltip.style.top = ty + 'px';
}

function hideTooltip() {
  tooltip.style.display = 'none';
}

// ===== D3 HIERARCHY =====
let hierarchy = null;

function buildHierarchy(data) {
  hierarchy = d3.hierarchy(data)
    .sum(d => d.size || 0)
    .sort((a, b) => (b.value || 0) - (a.value || 0));
  currentZoomNode = hierarchy;
  return hierarchy;
}

// ===== SEARCH =====
function matchesSearch(d) {
  if (!searchTerm) return true;
  const name = (d.data.name || '').toLowerCase();
  return name.includes(searchTerm);
}

// ===== TREEMAP =====
function renderTreemap() {
  const viz = document.getElementById('viz');
  viz.innerHTML = '';
  const width = viz.clientWidth;
  const height = viz.clientHeight;

  const svg = d3.select(viz).append('svg')
    .attr('width', width)
    .attr('height', height);

  const root = currentZoomNode;
  const treemapLayout = d3.treemap()
    .size([width, height])
    .paddingTop(d => d === root ? 0 : 20)
    .paddingInner(2)
    .paddingOuter(2)
    .round(true);

  // Create a copy of the subtree for layout
  const subRoot = d3.hierarchy(root.data)
    .sum(d => d.size || 0)
    .sort((a, b) => (b.value || 0) - (a.value || 0));

  treemapLayout(subRoot);

  // Map back parent references for breadcrumb
  function mapParents(node, parentInOriginal) {
    node._originalParent = parentInOriginal;
  }

  const cell = svg.selectAll('g')
    .data(subRoot.descendants())
    .join('g')
    .attr('transform', d => `translate(${d.x0},${d.y0})`);

  // Rectangles
  cell.append('rect')
    .attr('width', d => Math.max(0, d.x1 - d.x0))
    .attr('height', d => Math.max(0, d.y1 - d.y0))
    .attr('fill', d => {
      if (d.children) {
        return d.depth === 0 ? 'transparent' : 'rgba(255,255,255,0.03)';
      }
      const color = getTypeColor(d.data.type || 'Other');
      const opacity = searchTerm ? (matchesSearch(d) ? 0.7 : 0.08) : 0.7;
      return d3.color(color).copy({ opacity });
    })
    .attr('stroke', d => {
      if (d.children) return 'rgba(255,255,255,0.08)';
      if (searchTerm && matchesSearch(d)) return '#fff';
      return 'none';
    })
    .attr('stroke-width', d => searchTerm && matchesSearch(d) ? 2 : 0)
    .attr('rx', 2)
    .style('cursor', d => d.children ? 'pointer' : 'default')
    .on('mousemove', (e, d) => showTooltip(e, d))
    .on('mouseleave', hideTooltip)
    .on('click', (e, d) => {
      if (d.children) {
        // Find matching node in original hierarchy
        const path = [];
        let n = d;
        while (n.parent) {
          path.unshift(n.data.name);
          n = n.parent;
        }
        let target = currentZoomNode;
        // Navigate from current zoom node through the path
        // Since subRoot is rooted at currentZoomNode.data, the path from subRoot corresponds to children of currentZoomNode
        let origTarget = hierarchy;
        // Find the node in the original hierarchy by path from root
        const fullPath = [];
        let cz = currentZoomNode;
        while (cz && cz.parent) {
          fullPath.unshift(cz.data.name);
          cz = cz.parent;
        }
        const combined = [...fullPath, ...path];
        let t = hierarchy;
        for (const seg of combined) {
          if (t.children) {
            const found = t.children.find(c => c.data.name === seg);
            if (found) t = found;
            else break;
          }
        }
        currentZoomNode = t;
        renderBreadcrumb(currentZoomNode);
        renderTreemap();
      }
    });

  // Folder labels
  cell.filter(d => d.children && d.depth > 0)
    .append('text')
    .attr('x', 4)
    .attr('y', 14)
    .attr('fill', 'rgba(255,255,255,0.5)')
    .attr('font-size', '11px')
    .attr('font-family', 'inherit')
    .text(d => {
      const w = d.x1 - d.x0;
      if (w < 30) return '';
      const name = d.data.name;
      const maxChars = Math.floor(w / 7);
      return name.length > maxChars ? name.slice(0, maxChars) + '‚Ä¶' : name;
    });

  // File labels
  cell.filter(d => !d.children)
    .append('text')
    .attr('x', 4)
    .attr('y', 14)
    .attr('fill', d => {
      if (searchTerm && !matchesSearch(d)) return 'rgba(255,255,255,0.1)';
      return 'rgba(255,255,255,0.85)';
    })
    .attr('font-size', '10px')
    .attr('font-family', 'inherit')
    .text(d => {
      const w = d.x1 - d.x0;
      const h = d.y1 - d.y0;
      if (w < 30 || h < 16) return '';
      const maxChars = Math.floor(w / 6.5);
      const name = d.data.name;
      return name.length > maxChars ? name.slice(0, maxChars) + '‚Ä¶' : name;
    });

  // File size sublabel
  cell.filter(d => !d.children)
    .append('text')
    .attr('x', 4)
    .attr('y', 26)
    .attr('fill', 'rgba(255,255,255,0.35)')
    .attr('font-size', '9px')
    .attr('font-family', 'inherit')
    .text(d => {
      const w = d.x1 - d.x0;
      const h = d.y1 - d.y0;
      if (w < 40 || h < 30) return '';
      return formatSize(d.data.size || 0);
    });

  renderBreadcrumb(currentZoomNode);
}

// ===== SUNBURST =====
function renderSunburst() {
  const viz = document.getElementById('viz');
  viz.innerHTML = '';
  const width = viz.clientWidth;
  const height = viz.clientHeight;
  const radius = Math.min(width, height) / 2;

  const svg = d3.select(viz).append('svg')
    .attr('width', width)
    .attr('height', height)
    .append('g')
    .attr('transform', `translate(${width / 2},${height / 2})`);

  const root = d3.hierarchy(currentZoomNode.data)
    .sum(d => d.size || 0)
    .sort((a, b) => (b.value || 0) - (a.value || 0));

  const partition = d3.partition()
    .size([2 * Math.PI, radius]);

  partition(root);

  const arc = d3.arc()
    .startAngle(d => d.x0)
    .endAngle(d => d.x1)
    .innerRadius(d => d.y0)
    .outerRadius(d => d.y1 - 1);

  const paths = svg.selectAll('path')
    .data(root.descendants().filter(d => d.depth > 0))
    .join('path')
    .attr('d', arc)
    .attr('fill', d => {
      if (d.children) return 'rgba(255,255,255,0.06)';
      const color = getTypeColor(d.data.type || 'Other');
      const opacity = searchTerm ? (matchesSearch(d) ? 0.75 : 0.1) : 0.75;
      return d3.color(color).copy({ opacity });
    })
    .attr('stroke', d => {
      if (searchTerm && matchesSearch(d) && !d.children) return '#fff';
      return 'rgba(10,10,10,0.8)';
    })
    .attr('stroke-width', d => searchTerm && matchesSearch(d) && !d.children ? 2 : 0.5)
    .style('cursor', d => d.children ? 'pointer' : 'default')
    .on('mousemove', (e, d) => showTooltip(e, d))
    .on('mouseleave', hideTooltip)
    .on('click', (e, d) => {
      if (d.children) {
        // Find in original hierarchy
        const path = [];
        let n = d;
        while (n.parent) {
          path.unshift(n.data.name);
          n = n.parent;
        }
        const fullPath = [];
        let cz = currentZoomNode;
        while (cz && cz.parent) {
          fullPath.unshift(cz.data.name);
          cz = cz.parent;
        }
        const combined = [...fullPath, ...path];
        let t = hierarchy;
        for (const seg of combined) {
          if (t.children) {
            const found = t.children.find(c => c.data.name === seg);
            if (found) t = found;
          }
        }
        currentZoomNode = t;
        renderBreadcrumb(currentZoomNode);
        renderSunburst();
      }
    });

  // Center label
  svg.append('text')
    .attr('text-anchor', 'middle')
    .attr('dy', '-0.2em')
    .attr('fill', 'rgba(255,255,255,0.6)')
    .attr('font-size', '14px')
    .attr('font-family', 'inherit')
    .text(currentZoomNode.data.name || 'root');

  svg.append('text')
    .attr('text-anchor', 'middle')
    .attr('dy', '1.2em')
    .attr('fill', 'rgba(255,255,255,0.3)')
    .attr('font-size', '11px')
    .attr('font-family', 'inherit')
    .text(formatSize(currentZoomNode.value || 0));

  renderBreadcrumb(currentZoomNode);
}

// ===== BUBBLES =====
function renderBubbles() {
  const viz = document.getElementById('viz');
  viz.innerHTML = '';
  const width = viz.clientWidth;
  const height = viz.clientHeight;

  const svg = d3.select(viz).append('svg')
    .attr('width', width)
    .attr('height', height);

  const root = d3.hierarchy(currentZoomNode.data)
    .sum(d => d.size || 0)
    .sort((a, b) => (b.value || 0) - (a.value || 0));

  const pack = d3.pack()
    .size([width, height])
    .padding(3);

  pack(root);

  const nodes = root.descendants();

  // Draw folder circles
  svg.selectAll('circle.folder')
    .data(nodes.filter(d => d.children))
    .join('circle')
    .attr('class', 'folder')
    .attr('cx', d => d.x)
    .attr('cy', d => d.y)
    .attr('r', d => d.r)
    .attr('fill', 'none')
    .attr('stroke', 'rgba(255,255,255,0.08)')
    .attr('stroke-width', 1)
    .style('cursor', d => d.depth > 0 ? 'pointer' : 'default')
    .on('mousemove', (e, d) => showTooltip(e, d))
    .on('mouseleave', hideTooltip)
    .on('click', (e, d) => {
      if (d.children && d.depth > 0) {
        const path = [];
        let n = d;
        while (n.parent) {
          path.unshift(n.data.name);
          n = n.parent;
        }
        const fullPath = [];
        let cz = currentZoomNode;
        while (cz && cz.parent) {
          fullPath.unshift(cz.data.name);
          cz = cz.parent;
        }
        const combined = [...fullPath, ...path];
        let t = hierarchy;
        for (const seg of combined) {
          if (t.children) {
            const found = t.children.find(c => c.data.name === seg);
            if (found) t = found;
          }
        }
        currentZoomNode = t;
        renderBreadcrumb(currentZoomNode);
        renderBubbles();
      }
    });

  // Draw file circles
  const fileNodes = nodes.filter(d => !d.children);
  svg.selectAll('circle.file')
    .data(fileNodes)
    .join('circle')
    .attr('class', 'file')
    .attr('cx', d => d.x)
    .attr('cy', d => d.y)
    .attr('r', d => d.r)
    .attr('fill', d => {
      const color = getTypeColor(d.data.type || 'Other');
      const opacity = searchTerm ? (matchesSearch(d) ? 0.7 : 0.08) : 0.7;
      return d3.color(color).copy({ opacity });
    })
    .attr('stroke', d => {
      if (searchTerm && matchesSearch(d)) return '#fff';
      return 'none';
    })
    .attr('stroke-width', d => searchTerm && matchesSearch(d) ? 2 : 0)
    .on('mousemove', (e, d) => showTooltip(e, d))
    .on('mouseleave', hideTooltip);

  // File labels
  svg.selectAll('text.file-label')
    .data(fileNodes.filter(d => d.r > 15))
    .join('text')
    .attr('class', 'file-label')
    .attr('x', d => d.x)
    .attr('y', d => d.y)
    .attr('text-anchor', 'middle')
    .attr('dominant-baseline', 'central')
    .attr('fill', d => {
      if (searchTerm && !matchesSearch(d)) return 'rgba(255,255,255,0.1)';
      return 'rgba(255,255,255,0.85)';
    })
    .attr('font-size', d => Math.min(d.r / 3, 11) + 'px')
    .attr('font-family', 'inherit')
    .text(d => {
      const maxChars = Math.floor(d.r * 2 / 7);
      const name = d.data.name;
      return name.length > maxChars ? name.slice(0, maxChars) + '‚Ä¶' : name;
    });

  // Folder labels
  svg.selectAll('text.folder-label')
    .data(nodes.filter(d => d.children && d.depth > 0 && d.r > 30))
    .join('text')
    .attr('class', 'folder-label')
    .attr('x', d => d.x)
    .attr('y', d => d.y - d.r + 14)
    .attr('text-anchor', 'middle')
    .attr('fill', 'rgba(255,255,255,0.35)')
    .attr('font-size', '10px')
    .attr('font-family', 'inherit')
    .text(d => {
      const maxChars = Math.floor(d.r * 2 / 7);
      const name = d.data.name;
      return name.length > maxChars ? name.slice(0, maxChars) + '‚Ä¶' : name;
    });

  renderBreadcrumb(currentZoomNode);
}

// ===== RENDER DISPATCHER =====
function render() {
  switch (currentMode) {
    case 'treemap': renderTreemap(); break;
    case 'sunburst': renderSunburst(); break;
    case 'bubbles': renderBubbles(); break;
  }
}

// ===== ZOOM =====
function zoomTo(node) {
  // Find the corresponding node in the original hierarchy
  if (node === hierarchy || !node.parent) {
    currentZoomNode = hierarchy;
  } else {
    currentZoomNode = node;
  }
  render();
}

// ===== INIT =====
async function openFolder() {
  try {
    const dirHandle = await window.showDirectoryPicker();
    fileCount = 0;

    // Show scanning
    document.getElementById('scanning').classList.add('active');
    document.getElementById('scanCount').textContent = '0';

    const children = await scanDirectory(dirHandle);
    rootData = {
      name: dirHandle.name,
      path: '',
      children,
    };

    document.getElementById('scanning').classList.remove('active');

    // Build hierarchy
    buildHierarchy(rootData);

    // Compute & render stats
    const stats = computeStats(rootData);
    renderStats(stats);

    // Show app
    document.getElementById('landing').style.display = 'none';
    document.getElementById('app').style.display = 'flex';
    document.getElementById('folderName').textContent = dirHandle.name;

    render();
  } catch (e) {
    document.getElementById('scanning').classList.remove('active');
    if (e.name !== 'AbortError') {
      console.error(e);
      alert('Error: ' + e.message);
    }
  }
}

// Check browser support
if (!('showDirectoryPicker' in window)) {
  document.getElementById('browserWarning').style.display = 'block';
  document.getElementById('openBtn').disabled = true;
  document.getElementById('openBtn').style.opacity = '0.3';
  document.getElementById('openBtn').style.cursor = 'not-allowed';
}

document.getElementById('openBtn').addEventListener('click', openFolder);
document.getElementById('newFolderBtn').addEventListener('click', openFolder);

// Mode buttons
document.querySelectorAll('.mode-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentMode = btn.dataset.mode;
    render();
  });
});

// Search
document.getElementById('searchBox').addEventListener('input', (e) => {
  searchTerm = e.target.value.toLowerCase().trim();
  render();
});

// Resize
window.addEventListener('resize', () => {
  if (rootData) render();
});
</script>
</body>
</html>
